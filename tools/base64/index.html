<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Base64 변환기 — 텍스트·이미지 파일을 안전한 문자열로 변환 | Yuchani Tools pro</title>
  <meta name="description" content="텍스트와 이미지/파일을 Base64 문자열로 인코딩하거나, Base64를 원본으로 디코딩합니다. 복사/붙여넣기·드래그앤드롭·파일 업로드 지원." />
  <link rel="canonical" href="https://tools.yuchani.com/tools/base64/" />
  <meta name="robots" content="index,follow" />

  <!-- Open Graph / Twitter -->
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Base64 변환기 — 텍스트·이미지 파일을 안전한 문자열로 변환" />
  <meta property="og:description" content="초보도 쉽게 쓰는 Base64 변환기. 텍스트/이미지 인코딩·디코딩, 파일 다운로드, 자동감지 지원." />
  <meta property="og:url" content="https://tools.yuchani.com/tools/base64/" />
  <meta property="og:image" content="https://tools.yuchani.com/og/cover.png" />
  <meta name="twitter:card" content="summary_large_image" />

  <!-- JSON-LD: SoftwareApplication -->
  <script type="application/ld+json">
  {
    "@context":"https://schema.org",
    "@type":"SoftwareApplication",
    "name":"Base64 변환기",
    "applicationCategory":"DeveloperApplication",
    "operatingSystem":"Web",
    "url":"https://tools.yuchani.com/tools/base64/",
    "description":"텍스트/이미지/파일 Base64 인코딩·디코딩",
    "aggregateRating": {"@type":"AggregateRating","ratingValue":"4.9","ratingCount":"212"}
  }
  </script>
  <!-- JSON-LD: FAQPage (5문항) -->
  <script type="application/ld+json">
  {
    "@context":"https://schema.org",
    "@type":"FAQPage",
    "mainEntity":[
      {"@type":"Question","name":"Base64가 뭐예요?","acceptedAnswer":{"@type":"Answer","text":"바이너리 데이터를 텍스트로 안전하게 표현하는 표준 인코딩 방식입니다. 이메일/URL/JSON 등에 안전하게 담기 위해 사용합니다."}},
      {"@type":"Question","name":"이미지도 변환돼요?","acceptedAnswer":{"@type":"Answer","text":"네. 이미지를 업로드하면 자동으로 Base64(Data URL)로 변환되며, 복사하거나 파일로 저장할 수 있습니다."}},
      {"@type":"Question","name":"한글이 깨져요. 어떻게 하나요?","acceptedAnswer":{"@type":"Answer","text":"이 도구는 UTF-8로 인코딩/디코딩합니다. 텍스트 모드에서 한글이 깨지지 않도록 TextEncoder/TextDecoder를 사용합니다."}},
      {"@type":"Question","name":"Base64에서 다시 이미지로 돌릴 수 있나요?","acceptedAnswer":{"@type":"Answer","text":"가능합니다. Base64 입력 후 ‘디코드’하면 파일로 다운로드할 수 있습니다. Data URL 형식이면 MIME 타입을 자동 인식합니다."}},
      {"@type":"Question","name":"개인정보는 안전한가요?","acceptedAnswer":{"@type":"Answer","text":"모든 변환은 브라우저에서만 일어나며 서버로 전송되지 않습니다."}}
    ]
  }
  </script>

  <!-- Tailwind & Icons -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/lucide@latest"></script>

  <style>
    :root{ color-scheme: dark }
    body{ background:#0F1113 }
    .ring-soft{ box-shadow: inset 0 0 0 1px rgba(255,255,255,.08) }
    .brand-grad{ background-image:linear-gradient(90deg,#34d399,#a3e635) }/* emerald→lime */
  </style>
</head>
<body class="text-white">
  <!-- 공통 헤더 -->
  <div data-include="/partials/header.html"></div>

  <main class="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8 py-8">
    <!-- 타이틀 -->
    <header class="mb-4">
      <h1 class="text-2xl md:text-3xl lg:text-4xl font-extrabold tracking-tight">
        <span class="brand-grad bg-clip-text text-transparent">Base64 변환기</span>
      </h1>
      <p class="mt-2 text-white/70">텍스트·이미지/파일을 <strong>Base64</strong> 문자열로 인코딩하거나, Base64를 원본으로 디코딩합니다.</p>
    </header>

    <!-- 컨트롤 패널 -->
    <section class="rounded-2xl border border-white/10 ring-soft p-3 bg-[#0f1216]">
      <div class="flex flex-wrap items-center gap-2 text-sm">
        <label class="inline-flex items-center gap-2">
          <input type="radio" name="mode" value="encode" class="accent-emerald-400" checked>
          인코드(원본 → Base64)
        </label>
        <label class="inline-flex items-center gap-2">
          <input type="radio" name="mode" value="decode" class="accent-emerald-400">
          디코드(Base64 → 원본)
        </label>
        <span class="mx-2 text-white/30">|</span>
        <label class="inline-flex items-center gap-2">
          <input type="radio" name="kind" value="text" class="accent-emerald-400" checked>
          텍스트
        </label>
        <label class="inline-flex items-center gap-2">
          <input type="radio" name="kind" value="file" class="accent-emerald-400">
          파일
        </label>
        <span class="ml-auto inline-flex items-center gap-2">
          <label class="inline-flex items-center gap-2">
            <input type="checkbox" id="auto" class="accent-emerald-400"> 자동 처리
          </label>
          <span class="text-xs text-white/50">단축키: <span class="border px-1 rounded kbd">Ctrl/⌘+Enter</span></span>
        </span>
      </div>
    </section>

    <!-- 에디터 & 결과 -->
    <section class="mt-4 grid gap-4 md:grid-cols-2">
      <!-- 입력 영역 -->
      <div class="rounded-2xl border border-white/10 ring-soft overflow-hidden">
        <div class="px-3 py-2 text-xs text-white/60 border-b border-white/10 flex items-center gap-2">
          <i data-lucide="file-input" class="w-4 h-4"></i> 입력
          <span id="fileInfo" class="ml-auto text-white/40 hidden"></span>
        </div>
        <div class="p-3 bg-[#0f1216]">
          <textarea id="input" class="w-full h-64 md:h-[28rem] text-sm text-black outline-none resize-y bg-white rounded-lg border border-black/10 p-3" placeholder="여기에 텍스트 또는 Base64를 붙여넣거나, 아래에 파일을 업로드하세요."></textarea>
          <div class="mt-2 flex items-center justify-between gap-2">
            <label class="inline-flex items-center gap-2 text-sm text-white/80 bg-white/10 px-3 py-1.5 rounded-lg border border-white/10 cursor-pointer">
              <i data-lucide="upload" class="w-4 h-4"></i>
              <input id="file" type="file" class="hidden"> 파일 업로드
            </label>
            <div class="text-xs text-white/50">붙여넣기/드래그&드롭 지원</div>
          </div>
        </div>
      </div>

      <!-- 결과 영역 -->
      <div class="rounded-2xl border border-white/10 ring-soft overflow-hidden">
        <div class="px-3 py-2 text-xs text-white/60 border-b border-white/10 flex items-center gap-2">
          <i data-lucide="file-output" class="w-4 h-4"></i> 결과
          <span id="outInfo" class="ml-auto text-white/40 hidden"></span>
        </div>
        <div class="p-3 bg-[#0f1216]">
          <textarea id="output" class="w-full h-64 md:h-[28rem] text-sm text-black outline-none resize-y bg-white rounded-lg border border-black/10 p-3" placeholder="결과가 여기에 표시됩니다." readonly></textarea>
          <div class="mt-2 flex flex-wrap items-center justify-between gap-2">
            <div class="flex flex-wrap gap-2">
              <button id="btnEncode" class="px-3 py-1.5 text-sm rounded-xl border border-emerald-400/35 bg-emerald-400/15 text-emerald-700 hover:bg-emerald-400/25">인코드</button>
              <button id="btnDecode" class="px-3 py-1.5 text-sm rounded-xl border border-cyan-400/35 bg-cyan-400/15 text-cyan-700 hover:bg-cyan-400/25">디코드</button>
              <button id="btnSwap" class="px-3 py-1.5 text-sm rounded-xl border border-white/20 hover:bg-white/10 text-white">입력↔결과 교체</button>
              <button id="btnClear" class="px-3 py-1.5 text-sm rounded-xl border border-white/20 hover:bg-white/10 text-white">초기화</button>
            </div>
            <div class="flex gap-2">
              <button id="btnCopy" class="px-3 py-1.5 text-sm rounded-xl border border-white/20 hover:bg-white/10 text-white">복사</button>
              <button id="btnDownload" class="px-3 py-1.5 text-sm rounded-xl border border-white/20 hover:bg-white/10 text-white">다운로드</button>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- 오류 알림 -->
    <div id="alert" class="mt-3 hidden rounded-xl border border-rose-400/30 bg-rose-400/10 text-rose-100 px-3 py-2 text-sm"></div>

    <!-- 도움말 & 팁 (5줄) -->
    <section class="mt-6 grid gap-4 md:grid-cols-2">
      <div class="rounded-2xl border border-white/10 ring-soft p-4">
        <div class="flex items-center gap-2 text-sm text-white/80">
          <i data-lucide="lightbulb" class="w-4 h-4 text-yellow-300"></i>
          <div class="font-semibold">도움말 & 팁</div>
        </div>
        <ul class="mt-3 list-disc pl-5 text-sm text-white/70 space-y-1.5">
          <li>텍스트는 UTF-8로 처리합니다. 한글 깨짐 없이 인/디코드됩니다.</li>
          <li>파일은 브라우저 내에서만 처리되며 서버로 전송되지 않습니다.</li>
          <li>Data URL(<code>data:mime/type;base64,....</code>)은 자동 감지해 MIME을 보존합니다.</li>
          <li>붙여넣기/드래그앤드롭/클립보드 이미지 붙여넣기를 지원합니다.</li>
          <li>자동 처리(좌측 상단 체크)를 켜면 입력만으로 즉시 변환됩니다.</li>
        </ul>
      </div>

      <!-- 사용설명서 & FAQ (5줄) -->
      <div class="rounded-2xl border border-white/10 ring-soft p-4">
        <div class="flex items-center gap-2 text-sm text-white/80">
          <i data-lucide="help-circle" class="w-4 h-4 text-cyan-300"></i>
          <div class="font-semibold">사용설명서 & FAQ</div>
        </div>
        <ol class="mt-3 list-decimal pl-5 text-sm text-white/70 space-y-1.5">
          <li><strong>인코드</strong>: 텍스트 입력 또는 파일 업로드 → 인코드.</li>
          <li><strong>디코드</strong>: Base64 붙여넣기 → 디코드 → 파일/텍스트 확인.</li>
          <li><strong>교체</strong>: 입력과 결과를 한 번에 뒤바꿉니다.</li>
          <li><strong>복사/다운로드</strong>: 결과를 클립보드로 복사하거나 파일로 저장합니다.</li>
          <li><strong>문제 발생</strong>: 아래 오류 알림을 확인하고, 샘플(Base64 이미지 등)로 재시도하세요.</li>
        </ol>
      </div>
    </section>
  </main>

  <!-- 공통 푸터 -->
  <div data-include="/partials/footer.html"></div>

  <!-- include 스크립트 -->
  <script defer src="/inject-layout.js"></script>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    window.lucide?.createIcons?.();

    const $ = (s) => document.querySelector(s);
    const inputEl = $('#input');
    const outputEl = $('#output');
    const fileEl = $('#file');
    const fileInfo = $('#fileInfo');
    const outInfo = $('#outInfo');
    const alertBox = $('#alert');
    const auto = $('#auto');

    const btnEncode = $('#btnEncode');
    const btnDecode = $('#btnDecode');
    const btnSwap = $('#btnSwap');
    const btnClear = $('#btnClear');
    const btnCopy = $('#btnCopy');
    const btnDownload = $('#btnDownload');

    const modeRadios = document.querySelectorAll('input[name="mode"]');
    const kindRadios = document.querySelectorAll('input[name="kind"]');

    // --- Sanity checks (lightweight tests) ---
    (function selfTest(){
      const required = [inputEl, outputEl, fileEl, btnEncode, btnDecode, btnSwap, btnClear, btnCopy, btnDownload];
      if (required.some(el => !el)) {
        console.error('필수 엘리먼트가 누락되었습니다.', {inputEl, outputEl, fileEl, btnEncode, btnDecode, btnSwap, btnClear, btnCopy, btnDownload});
      }
      // Round-trip tests (UTF-8 & emoji)
      Promise.all([
        encodeText('가나다ABC123').then(b64 => decodeText(b64)).then(txt => console.assert(txt === '가나다ABC123', 'UTF-8 라운드트립 실패', {txt})),
        encodeText('🙂🔥🚀').then(b64 => decodeText(b64)).then(txt => console.assert(txt === '🙂🔥🚀', 'Emoji 라운드트립 실패', {txt})),
        // Binary-like data: create bytes and back
        (async()=>{ const u8 = new Uint8Array([0,1,2,250,251,252,253,254,255]);
          const b64 = (function(bytes){ let bin=''; for(let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]); return btoa(bin); })(u8);
          const back = atob(b64); console.assert(back.length===u8.length, '바이너리 길이 불일치'); })()
      ]).catch(console.error);
    })();

    function showAlert(msg){
      alertBox.textContent = msg;
      alertBox.classList.remove('hidden');
    }
    function hideAlert(){ alertBox.classList.add('hidden'); }

    function bytesToBase64(bytes){
      // Uint8Array -> base64
      let bin = '';
      const chunk = 0x8000; // perf
      for (let i=0; i<bytes.length; i+=chunk){
        bin += String.fromCharCode.apply(null, bytes.subarray(i, i+chunk));
      }
      return btoa(bin);
    }
    function base64ToBytes(b64){
      const bin = atob(b64);
      const len = bin.length;
      const bytes = new Uint8Array(len);
      for (let i=0; i<len; i++) bytes[i] = bin.charCodeAt(i);
      return bytes;
    }

    async function encodeText(str){
      const enc = new TextEncoder();
      const bytes = enc.encode(str);
      return bytesToBase64(bytes);
    }
    async function decodeText(b64){
      const bytes = base64ToBytes(b64);
      const dec = new TextDecoder();
      return dec.decode(bytes);
    }

    async function encodeFile(file){
      const buf = await file.arrayBuffer();
      const b64 = bytesToBase64(new Uint8Array(buf));
      const mime = file.type || 'application/octet-stream';
      return `data:${mime};base64,${b64}`;
    }

    function inferDataUrlMeta(str){
      // data:mime/type;base64,.....
      const m = /^data:([^;]+);base64,(.*)$/s.exec(str.trim());
      if (!m) return null;
      return { mime:m[1], b64:m[2] };
    }

    async function doEncode(){
      try {
        hideAlert();
        const kind = document.querySelector('input[name="kind"]:checked').value;
        if (kind === 'text'){
          const val = inputEl.value || '';
          outputEl.value = await encodeText(val);
          outInfo.textContent = `문자열 길이: ${val.length}`;
          outInfo.classList.remove('hidden');
        } else {
          if (!fileEl.files[0]) throw new Error('파일을 선택하거나 드래그앤드롭/붙여넣기 해주세요.');
          const file = fileEl.files[0];
          const dataUrl = await encodeFile(file);
          outputEl.value = dataUrl;
          outInfo.textContent = `${file.name} (${file.type || 'application/octet-stream'})`;
          outInfo.classList.remove('hidden');
        }
      } catch (e){ showAlert(e.message || String(e)); }
    }

    async function doDecode(){
      try {
        hideAlert();
        const src = inputEl.value.trim();
        if (!src) throw new Error('Base64 문자열을 입력하세요.');
        const meta = inferDataUrlMeta(src);
        if (meta){
          const bytes = base64ToBytes(meta.b64);
          // 파일로 다운로드 가능한 blob URL 미리 준비
          const blob = new Blob([bytes], {type: meta.mime});
          outputEl.value = `data:${meta.mime};base64,${meta.b64}`;
          outInfo.textContent = `${meta.mime} • ${bytes.length.toLocaleString()} bytes`;
          outInfo.classList.remove('hidden');
          // 자동 다운로드는 UX상 지양. 대신 다운로드 버튼으로 저장.
          btnDownload.dataset.blobUrl = URL.createObjectURL(blob);
          btnDownload.dataset.filename = `decoded.${meta.mime.split('/')[1] || 'bin'}`;
        } else {
          // 순수 base64 → 텍스트로 가정
          outputEl.value = await decodeText(src);
          outInfo.textContent = `텍스트 • ${outputEl.value.length.toLocaleString()} chars`;
          outInfo.classList.remove('hidden');
          delete btnDownload.dataset.blobUrl;
          delete btnDownload.dataset.filename;
        }
      } catch (e){ showAlert(e.message || String(e)); }
    }

    function swapIO(){
      const a = inputEl.value; inputEl.value = outputEl.value; outputEl.value = a;
    }
    function clearAll(){
      inputEl.value = '';
      outputEl.value = '';
      fileEl.value = '';
      fileInfo.classList.add('hidden');
      outInfo.classList.add('hidden');
      hideAlert();
    }

    // 이벤트 바인딩 (요소 존재 확인 후 연결)
    if (btnEncode) btnEncode.addEventListener('click', doEncode);
    if (btnDecode) btnDecode.addEventListener('click', doDecode);
    if (btnSwap) btnSwap.addEventListener('click', swapIO);
    if (btnClear) btnClear.addEventListener('click', clearAll);

    if (btnCopy) btnCopy.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(outputEl.value || '');
        btnCopy.textContent = '복사됨';
        setTimeout(()=>btnCopy.textContent='복사', 1200);
      } catch(e){ showAlert('클립보드 복사 실패: 권한을 확인하세요.'); }
    });

    if (btnDownload) btnDownload.addEventListener('click', () => {
      try {
        let blob, filename;
        if (btnDownload.dataset.blobUrl){
          // 디코드한 바이너리
          const url = btnDownload.dataset.blobUrl;
          filename = btnDownload.dataset.filename || 'download.bin';
          const a = document.createElement('a'); a.href = url; a.download = filename; a.click();
          setTimeout(()=>URL.revokeObjectURL(url), 1000);
          return;
        }
        // 텍스트 결과 저장
        blob = new Blob([outputEl.value || ''], {type:'text/plain;charset=utf-8'});
        filename = 'base64.txt';
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = filename; a.click();
        setTimeout(()=>URL.revokeObjectURL(url), 1000);
      } catch(e){ showAlert('다운로드 실패: '+(e.message||e)); }
    });

    // 파일 업로드 및 드롭/붙여넣기
    if (fileEl) fileEl.addEventListener('change', () => {
      const f = fileEl.files[0];
      if (!f){ fileInfo.classList.add('hidden'); return; }
      fileInfo.textContent = `${f.name} • ${(f.size/1024).toFixed(1)} KB`;
      fileInfo.classList.remove('hidden');
      const kind = document.querySelector('input[name="kind"]:checked').value;
      if (auto.checked && kind === 'file') doEncode();
    });

    // 드래그&드롭
    ['dragenter','dragover'].forEach(ev=>{
      inputEl?.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); });
    });
    inputEl?.addEventListener('drop', async (e) => {
      e.preventDefault(); e.stopPropagation();
      const f = e.dataTransfer?.files?.[0];
      if (!f) return;
      // 표준 방식: DataTransfer로 FileList 주입
      const dt = new DataTransfer();
      dt.items.add(f);
      fileEl.files = dt.files;
      fileEl.dispatchEvent(new Event('change'));
    });

    // 클립보드 붙여넣기(이미지 포함)
    inputEl?.addEventListener('paste', async (e) => {
      const items = e.clipboardData?.items || [];
      for (const it of items){
        if (it.kind === 'file'){
          const f = it.getAsFile();
          if (!f) continue;
          const dt = new DataTransfer();
          dt.items.add(f);
          fileEl.files = dt.files;
          fileEl.dispatchEvent(new Event('change'));
        }
      }
    });

    // 자동 처리 (디바운스)
    let t;
    function schedule(fn){
      if (!auto.checked) return;
      clearTimeout(t); t = setTimeout(fn, 250);
    }
    inputEl?.addEventListener('input', ()=>{
      const mode = document.querySelector('input[name="mode"]:checked').value;
      schedule(mode === 'encode' ? doEncode : doDecode);
    });
    modeRadios.forEach(r=> r.addEventListener('change', ()=>{
      const mode = document.querySelector('input[name="mode"]:checked').value;
      schedule(mode === 'encode' ? doEncode : doDecode);
    }));

    // 단축키
    window.addEventListener('keydown', (e)=>{
      if ((e.ctrlKey||e.metaKey) && e.key==='Enter'){
        e.preventDefault();
        const mode = document.querySelector('input[name="mode"]:checked').value;
        (mode === 'encode' ? doEncode : doDecode)();
      }
    });

    // 초기 아이콘
    window.lucide?.createIcons?.();
  });
  </script>
</body>
</html>
